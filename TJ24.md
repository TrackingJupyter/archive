Welcome to this twenty-fourth edition of the _Tracking Jupyter_ newsletter (#TJ24).  
  
Since getting out of the weekly / fortnightly cycle, I'm noticing how quickly some of the "news" items I queue up are dating. Which has got me wondering about what sort of form, style and content an erratically occasional newsletter should take...

News and Announcements
----------------------

Keeping up with its monthly releases, IPython v7.10 is [now out](https://ipython.readthedocs.io/en/stable/whatsnew/version7.html#ipython-7-10-0). Support for Python 3.5 has been dropped.  
  
I belatedly note that the November Python extension update for **VS Code** [is long since out](https://devblogs.microsoft.com/python/python-in-visual-studio-code-november-2019-release/) _\[and the December one is probably due to land any time...—Ed.\]_ bringing Altair chart support and line numbering within code blocks.  
  
If you pay for your editor, the [**PyCharm** 2019.3](https://blog.jetbrains.com/pycharm/2019/12/pycharm-2019-3-is-out-now/) release is out now, offering widget support and runtime code completion in the Jupyter views.  
  
Even as VS Code increasingly lets you edit Jupyter documents inside that environment, the **Jupytext** Jupyter extension goes the other way, letting you edit Python and Markdown documents, among other things, in a notebook UI. It recently [bumped up](https://gist.github.com/mwouts/724efe5e00654fc2145a4c916796e071) to v1.3, with changes including improved UI tools for pairing against multiple formats, multi-line comments in Python scripts, and improved ways of handling raw cells in Markdown and encoding cell metadata. Supported formats now also include Powershell, Rust and Robot Framework, the latter two contributed. Jupytext also plays nicely with things like Papermill (parameterised notebook execution) as described in this post on [Automated reports with Jupyter Notebooks using Jupytext and Papermill](https://medium.com/capital-fund-management/automated-reports-with-jupyter-notebooks-using-jupytext-and-papermill-619e60c37330). A **Vim** plugin for editing Jupyter notebook (ipynb) files via the jupytext percent format, [jupycent](https://github.com/gabenespoli/vim-jupycent), also appeared recently, suggesting that an ecosystem is now developing around Jupytext _\[jupyter-book and nbsphinx already make use of Jupytext, for example...—Ed.\]_.  
  
If you prefer notebook-lite UIs, **nteract** is now available [in the browser](https://blog.nteract.io/nteract-on-jupyter-53cc2c38290d), as a Jupyter server server extension. So now a well as JupyterLab _/lab_ views down the server path, you can also have _/nteract_ views.  
  
And if you want to access remote **Databricks GPUs** from your local JupyterLab server, it seems [you now can](https://databricks.com/blog/2019/12/03/jupyterlab-databricks-integration-bridge-local-and-remote-workflows.html)...  
  
Great to see an [announcement](https://chanzuckerberg.com/eoss/proposals) from the Chan-Zuckerberg Initiative's _Essential Open Source Software for Science_ program that includes funding for a [**JupyterHub** Contributor in Residence](http://chanzuckerberg.com/eoss/proposals/jupyterhub-contributor-in-residence-program/) program, sustainability projects on [scaling **OpenRefine**](https://chanzuckerberg.com/eoss/proposals/scaling-openrefine/) and containerized reproducible analyses with [**Rocker**,​](https://chanzuckerberg.com/eoss/proposals/maintaining-rocker-sustainability-for-containerized-reproducible-analyses/) and development projects ensuring the continued growth of [**pandas**](https://chanzuckerberg.com/eoss/proposals/ensuring-the-continued-growth-of-pandas/), developing [**matplotlib**](https://chanzuckerberg.com/eoss/proposals/matplotlib-foundation-of-scientific-visualization-in-python/) as foundation of scientific visualization in Python and developing [**scipy**](https://chanzuckerberg.com/eoss/proposals/a-solid-foundation-for-statistics-in-python-with-scipy/) as a solid foundation for statistics in Python.  
  
If you're looking for funding yourself, the call for proposals for **Jupyter Community Workshops**, Jan-Aug 2020 (supported by Bloomberg and AWS), is open until [Sunday, December 15th, 2019](https://blog.jupyter.org/jupyter-community-workshops-call-for-proposals-for-jan-aug-2020-710f687e30f4).  
  
Or maybe a new job? If so, and you fancy running a hosted notebook service for the UK education sector (schools, FE, HE), Edina at the University of Edinburgh are looking got a **service manager** to run the [noteable](https://www.jobs.ac.uk/job/BWY175/service-manager) hosted/cloud notebooks service.  
  
At their annual _re:Invent_ event, Amazon have made their traditional [slew](https://aws.amazon.com/blogs/aws/aws-launches-previews-at-reinvent-2019-tuesday-december-3rd/) of AWS related announcements. In particular, **Amazon SageMaker Studio** was presented as _"__the first fully integrated development environment (IDE) for machine learning (ML)"_ that _"unifies all the tools needed for ML development: write code, track [experiments](https://aws.amazon.com/blogs/aws/amazon-sagemaker-experiments-organize-track-and-compare-your-machine-learning-trainings/), visualize data, and perform [debugging](https://aws.amazon.com/blogs/aws/amazon-sagemaker-debugger-debug-your-machine-learning-models/) and monitoring"_. Make of that what you will, but note this — the first class UI to the Studio appears to be JupyterLab. In the first case, _"with Amazon SageMaker Notebooks, you can enjoy an enhanced notebook experience that lets you easily create and share Jupyter notebooks"_; in the second, custom tabs inside the JupyterLab experience offer experiment tracking and job monitoring as well as ML model automated builds, debugging and monitoring. _\[By the by, I also note you can now [co-lo AWS hardware](https://aws.amazon.com/blogs/aws/aws-outposts-now-available-order-your-racks-today/)... —Ed.\]_  
  
Part of the rationale for my starting _Tracking Jupyter_ was to help gather items that might be useful for Jupyter advocacy projects _\[tho' I've spectacularly failed in making any progress on that front in my own institution for the 5th year in a row...—Ed.\]_. As it is, TJ is maybe a bit too scattergun an approach for that, so the JupyterHub [Institutional FAQ](https://jupyterhub.readthedocs.io/en/latest/getting-started/institutional-faq.html) may be a better start for anyone looking on pointers for how to start putting a case together and how to start allaying concerns. If folk are swayed by prestigious journals, a [Nature](https://www.nature.com/articles/d41586-019-03366-x) article last month describing how to _"Make code accessible with cloud services"_ such as MyBinder and Nextjournal _\[both oft mentioned in Tracking Jupyter —Ed.\]_, as well as Gigantum and Code Ocean, deployers of _"container platforms that let researchers run each other’s software — and check the results"_; I guess it may help make the case for reproducible computational environments and tease the question _"so could we do this locally?"_.In which case, this [slidedeck](https://blog.openshift.com/wp-content/uploads/OpenShift-Commons-SF-Agile-Data-Science-ExxonMobil.pdf) onOpenShift and Machine Learning at ExxonMobil which in passing shows how Jupyter notebooks may themselves in support of advocacy around a cloud based machine learning stack may be worth a quick read...  
  
As if Jupytext isn't keeping him busy enough, maintainer Marc Wouts has another new project on the go: itables \[[repo](https://mwouts.github.io/itables/)\] offers _\[yet another? —Ed.\]_ alternative to the range of interactive grid / dataframe viewers available for notebooks and JupyterLab. _\[I've had a thematic round up on related items languishing in the Tracking Jupyter queue for ages, which I really should try to get round to finishing off for future issue...—Ed.\]_  
  
This could be quite handy for those of you who, like me, tend to have more than a few open tabs on the go at any one time: [Save-and-Quit](http://https://github.com/lsst-sqre/jupyterlab-savequit) functionality for JupyterLab-in-JupyterHub that _"allows the user to save all notebooks, stop the container, and log out of the hub"_. Just the sort of thing for an institutionally deployed JupyterHub, methinks...  
  
**Docker** may not have given **Kitematic** any love since they first acquired it, but it's been forked and rebooted in the form of [ContainDS](https://containds.com/) (available for Windows and Mac, at least...). Improvements over Kitematic include better support for mounting local directories into a container and clicking through to a notebook server in your browser (the first-run token is managed for you...). Even more impressive is "**local Binder**" facility that lets you build and launch containers from remote repositories or a local directory using repo2docker. _\[Thinking through some ways of integrating nbgitpuller to exploit the idea of "Binder base boxes" could be really interesting here, too... —Ed.\]_  
  
A phrase presumably intended to allay, rather than excite, the fears of everyone of who's concerned about the ways in which Jupyter user environments are used to develop code, _"Use Jupyter Notebooks for everything"_ was the strapline on the fast.ai [blog post](https://www.fast.ai/2019/12/02/nbdev/) announcing **[nbdev](https://nbdev.fast.ai/)** \[[repo](https://github.com/fastai/nbdev/)\], their workflow and tooling package to help you create "delightful" _\[is that term back in vogue again?! —Ed.\]_ Python projects using Jupyter notebooks. _nbdev_ allows you to _"put all your code, tests and documentation in one place"_, using an _#export_ flag at the start of a code cell to mark the contents of that cell as exportable to a separate source code file; a limited ability to sync changes made to the code file back into the parent notebook is also possible _\[there are lessons to be learned from Jupytext about how to do this more smoothly, and completely, methinks? —Ed.\]_. Tests can be defined and run _in situ_, and integration with CI tools such as Github Actions is provided. Docs can be generated directly from notebooks, and completed packages built and pushed to PyPi.  
  
As well as "pro-developer" support, **formal proofs** of code is another area that is arguably lacking in a lot of Jupyter notebook use... But what if you do want to do those proofs in a notebook environment? For any [TLA+](https://lamport.azurewebsites.net/tla/tla.html) afficionados out there, [tlaplus\_jupyter](https://github.com/kelvich/tlaplus_jupyter) brings you a Jupyter kernel for TLA⁺. _\[I didn't know either... So, erm, "a high-level language for modeling programs and systems--especially concurrent and distributed ones"...—Ed.\]_  
   
One of the things I've found myself repeatedly over recent years is dropping minimally viable notebook based code fragments and demos in Github gists. So the recent [cocode.ai](https://www.cocode.ai/) community'n'JupyterLab extension announcement caught my eye, offering as it does a_"code snippet search"_ library that _"helps programmers to find the right code snippets ('bricks') that they're looking for and allows them to save bricks for easy access in the future"_. Bricks are Jupyter notebooks containing the "key code", an example, and some narrative text that provides the ability to "learn more" _\[think of them as akin to reversed good-answer-then-question Stack Overflow posts...—Ed.\]_. Bricks form part of a common repository, but can also be created and saved locally. _\[The demo video on the homepage is worth a watch...—Ed.\]_ It's maybe in beta (you need to sign up), and I've no idea what the business model is... _\[I'll never make it as a journalist...—Ed.\]_

Notebook Practice
-----------------

As with any new technology or medium, the development of uninformed, have-a-go practice often appears in advance of informed practice. If notebooks are to become _a thing_ in academic publishing, we might expect standards to emerge that situate the notebooks in the wider, formalised structure of academic publishing so that they contribute to that system in an appropriate way.  
  
So here are some readings that speak to the current state of notebooks in academic communications.  
  
Once you get into the swing of it, it's easy to hack together code in notebooks, and easy to hack together low quality code. But with so many notebooks out there, how can we even begin to get a sense of code quality, in general, across those notebooks? _Better Code, Better Sharing:On the Need of Analyzing Jupyter Notebooks_ \[[arXiv:1906.05234](https://arxiv.org/abs/1906.05234)\] explored the extent to which code in a sample of Jupyter notebooks respected recommended Python programming conventions and made use of unused variables exist in Jupyter notebooks and deprecated library functions used in Jupyter notebooks, identifying the need for the community to enforce good coding styles, improve code quality and reliability, apply best practices for software quality _\[testing, in other words...—Ed.\]_ and ensuring a good balance between text and code. A separate _"Large-scale Study About Quality and Reproducibility of Jupyter Notebooks"_ \[[DOI: 10.1109/MSR.2019.00077](https://doi.org/10.1109/MSR.2019.00077) and [PDF](http://www.ic.uff.br/~leomurta/papers/pimentel2019a.pdf)\], on 1.4 million notebooks found on Github asked how literate programming features are used in notebooks _\[markdown cells are used... —Ed.\]_, how notebooks are named _\[generally meaningful but not conventional...—Ed.\]_, how they use modules, functions, and classes _\[hands up if you understand classes...—Ed.\]_, how they are tested _\[you're having a laugh...—Ed.\]_, whether they are stored with executed cell output _\[yes...—Ed.\]_, whether any recorded cell execution appears to be in linear order _\[it's all over the place...—Ed.\]_, and how reproducible the notebooks are, for example, in terms of declared versions of imported libraries _\[not really...—Ed.\]_.  
  
_\[Loosely related to code presentation and quality, I've previously made [some notes](https://blog.ouseful.info/2019/09/24/nudging-student-coders-into-conforming-with-the-pep8-python-style-guide/) for myself on "Nudging Student Coders into Conforming with the PEP8 Python Style Guide Using Jupyter Notebooks, flake8 and pycodestyle\_magic Linters"... —Ed.\]_  
  
In terms of notebooks that have made it, in some way, into formal publications, _"Reproducible Research is more than Publishing Research Artefacts: A Systematic Analysis of Jupyter Notebooks from Research Articles"_ \[[arxiv:1905.00092](https://arxiv.org/abs/1905.00092)\] reviewed five publications from PubMed Central, performing a metadata analysis of the repository that is used _\[Github, Supplementary Material, Zenodo and GIN...—Ed.\]_ and the source code license _\[do I need one? Erm, MIT, GPL 3, CC0 1,0?! —Ed.\]_; and a reproducibility analysis, noting the number of notebooks mentioned compared to published _\[mostly the same...—Ed.\]_, where source code artefacts are documented besides the publication _\[sometimes...—Ed.\]_, where software requirements documentation can be found _\[all over the place...—Ed.\]_, whether the computing environment is available or can be reconstructed from the documentation _\[not really...—Ed.\]_, whether the complete raw data of the study is available _\[it's my data, not yours...—Ed.\]_ and whether any provided Jupyter notebook be completely re-executed with the same results _\[no...—Ed.\]_.  
  
Effective citation is also an important part of scholarly communication, so how do you cite a notebook? _Jupyter notebooks as discovery mechanisms for open science: Citation practices in the astronomy community_ \[[DOI: 10.1109/MCSE.2019.2932067](https://doi.org/10.1109/MCSE.2019.2932067)\] reports on _"a study of references to Jupyter notebooks in astronomy over a 5-year period (2014-2018)"_, noting that _"references increased rapidly, but fewer than half of the references led to Jupyter notebooks that could be located and opened"_. It also discusses how folk might be able to do it better... _\[I think... maybe... paywalled... —Ed.\]_

Environmentally Speaking...
---------------------------

If you're a conda fan, you probably have environments everywhere. So how about a Jupyter kernel for — and from — each of your **conda** environments _\[I think?! —Ed\]_? [nb\_conda\_kernels](https://github.com/Anaconda-Platform/nb_conda_kernels).  
  
And here's another twist on conda environments - use them to create different notebook environments, which is to say, notebook environments with different pre-enabled extensions, in this case appropriate for authoring maths chapters:[jupyter-forchaps](https://github.com/alugowski/jupyter-forchaps). _\[Makes me wonder: is there a meta nbextensions configurator that would let you specify a set of enabled configurations as an "extension set" and then associate this with a particular notebook directory path. Those notebooks would then open into an environment with particular extension enabled, the name/label of the environment being displayed on the right side of the notebook header? —Ed.\]_  
  
In passing, a handful more of things for the maths fans: [pyganja](https://github.com/pygae/pyganja) offers a visualisation library for geometric algebra with [cefpython](https://github.com/cztomczak/cefpython)_ \["Python bindings for the Chromium Embedded Framework" apparently...—Ed.\]_ and [ganja.js](https://github.com/enkimute/ganja.js), the _Javascript Geometric Algebra Generator_. It also plays nicely with the [clifford](https://github.com/pygae/clifford) numerical geometric algebra Python package.  Although from the repo commit stamps, [mathbox](https://github.com/znah/mathbox) (_"presentation-quality WebGL math graphing"_) looks like it may be a bit stale, there are some _nbviewer_ rendered [notebook](https://nbviewer.jupyter.org/github/znah/mathbox/blob/jupyter/examples/notebooks/mathbox.ipynb) [demos](https://nbviewer.jupyter.org/github/znah/mathbox/blob/jupyter/examples/notebooks/mathbox.ipynb) that look quite pretty. And finally, this may helpful for instructors wanting to create animated explanatory maths tutorials: [jupyter-manim](https://github.com/krassowski/jupyter-manim), some cell magic to integrate the [manim](https://github.com/3b1b/manim) animation engine developed for just that purpose.

Ramblings...
------------

A couple of days ago, I idly wondered on the Twitterz about whether there was a way I could connect to a  notebook kernel running on Google Colab from my own local notebook server _\[seems only fair, right? After all, you can [connect to a local kernel from Colab](https://research.google.com/colaboratory/local-runtimes.html), albeit it with Colab GPU support as[this post](https://medium.com/@jasonrichards911/getting-local-with-google-colab-a4d69f373364) suggests... And it'd mean free GPUs locally, which would be good for edu...—Ed.\]_. I imagined something like an [nb2kg](https://github.com/jupyter/nb2kg) extension _\[now a native part of Jupyter noteooks...—Ed.\]_ that would let me connect to Colab rather than my own org's enterprise kernel gateway _\[I wish! Or maybe noteable will offer this sort of thing?—Ed.\]_ The reality seems it may be possible via an ssh tunnel using something like [ngrok](https://ngrok.com/) _\[[example](https://imadelhanafi.com/posts/google_colal_server/), perhaps, though I haven't tried it yet...—Ed.\]_. By chance, a recent post on the Paypal Engineering blog describes their set up for [bringing GPU-powered Jupyter Notebooks](https://medium.com/paypal-engineering/accelerating-machine-learning-time-to-market-with-gpu-powered-jupyter-notebooks-d5ef6db8c4ce) to their analysts: Jupyter Enterprise Gateway fronting a Kubernetes cluster that spans CPU and GPU machines (see [#TJ4](https://github.com/TrackingJupyter/archive/blob/master/TJ4.md#corporate-adoption-and-support) and [#TJ8](https://github.com/TrackingJupyter/archive/blob/master/TJ8.md#news-and-announcements) for more on PayPal's Jupyter notebook extensions).  
  
By chance, (and as noted in the news section), I just noticed that another post that appeared a couple of days ago describes how to access Databricks Spark Workspaces and GPUs from local JupyterLab instances. The recipe is described here: [New Databricks Integration for Jupyter Bridges Local and Remote Workflows](https://databricks.com/blog/2019/12/03/jupyterlab-databricks-integration-bridge-local-and-remote-workflows.html).  
  
I've also been wondering whether [Amazon Ignite](https://ignite.amazon.com/), the platform for selling original digital educational resources announced last month, will soon open up a JupyterHub gateway for selling not just notebook based materials, but also the means of delivering them? Or maybe they'd buy something like the notebook powered [educative.io](https://www.educative.io/), which claims to offer _"rich, text-based courses with embedded coding environments make learning a breeze"_. Either way, how might that affect the noteable service roadmap?  
  
Related to this, and something I missed at the time, was an [announcement](https://www.businesswire.com/news/home/20190916005213/en/O%E2%80%99Reilly-Adds-New-Learning-Formats-Learning-Platform) back in September that O'Reilly had [added](https://www.oreilly.com/online-learning/introducing-jupyter-notebooks.html) Jupyter notebooks to their online learning platform... And it's not just notebooks — since March, there have also been [dashboards](https://www.oreilly.com/pub/pr/3273) that deliver _"learning impact data to the enterprise"_, providing a _"a single-pane-of-glass view into the learning behaviors of users, generating actionable data for business leaders"_ and other Wizard of Oz-ery... _\[Now that's probably what I should be pushing in order to get notebooks adopted in my org... :-(—Ed.\]_

Continuous Integration and Automated Builds
-------------------------------------------

Sharing reproducible code is one of the motivating reasons behind the Jupyter project and making computational environments shareable is a important part of that, as applications like Binderhub/MyBinder and the Binder [Reproducible Execution Environment Specification (REES)](https://repo2docker.readthedocs.io/en/latest/specification.html) demonstrate. Continuous integration, the art of invisibly getting other computers to build your project (or shareable computational environment...) for you every time you push to Github _\[it's never been easier to unknowingly trigger huge amounts of computation, bandwidth and energy consumption of the back of every minor typo correction in your README, has it?! —Ed.\]_ is related to this, and is something that's crossing my radar more and more, in part as I learn to automate more and more of my own side-project activities.  
  
MyBinder offers a lazy way of doing this, building a new image, if necessary, when a Binder instance is requested. But if you want to build a Docker image that you can share publicly on Dockerhub, for example, from your repo then either need to configure a Dockerhub action to watch the repo and build a new container when an appropriate commit is made to the repo, _or_ build an image and push it to Dockerhub using another continuous build service. _\[By the by, I forget where I saw this, but using {sourceref} as the tag and __/^(\[^m\]|.\[^a\]|..\[^s\]|...\[^t\]|....\[^e\]|.....\[^r\]|.{0,5}$|.{7,})/ as the source in a Dockerhub build rule will build from branches __other than master_ _and tag the image with the branchname. Is there a simpler, approved way of doing this?! —Ed.__\]_  
  
The "official" [continuous-build](https://github.com/binder-examples/continuous-build/) Binder example uses Circle.CI and demonstrates _"how to use repo2docker to build a container and push it to Dockerhub for others to use"_. The [pangeo-stacks](https://github.com/pangeo-data/pangeo-stacks) repo shows how to use Travis to a similar end.  
  
For Github users, the native [Github Actions](https://github.com/features/actions) automation route may be more convenient, such as using this [recipe](https://github.com/scottyhq/repo2docker-githubci) or this actual [repo2docker-action](https://github.com/machine-learning-apps/repo2docker-action) to build a Docker image using _repo2docker_ and then push it to Dockerhub following a Github commit; (see also this [Jupyter discourse thread](https://discourse.jupyter.org/t/github-actions-binder/2651) on GitHub Actions and Binder).  
  
And for Google Cloud Platform / Google Cloud Build users, this [article](https://blog.kovalevskyi.com/continues-integration-for-your-jupyter-notebooks-on-github-with-gcp-f72af5b08bcd) on _"__Continuous Integration For Your Jupyter Notebooks On GitHub With GCP"_ describes "a fully configured example of CI on GitHub that you can use as a reference example on your project" _\[apparently...—Ed.\]_.  
  
In terms of use cases, another example of how to use CI is building a documentation site that draws on something like _Jupyter Book_ or _nbjekyll_ to run a Jupyter source document through _nbconvert_ to generate an output document that includes code generated output content _\[my own demos for these are [here](https://github.com/ouseful-testing/jupyter-book-autobuild) (Jupyter Book/sphinx) and [here](https://github.com/ouseful-template-repos/oer-md-publish) (nbjekyll). —Ed.\]_.

Keeping Track of Cell History...
--------------------------------

Depending on how you use them, one of the great things about notebooks _\[which can also be a not so great thing...—Ed.\]_ is the way the history of an idea can be captured as code is developed across notebook code cells. But iterative code development can also take place _within_ a code cell; and whilst each cell maintains its own history, that history is lost when you close a notebook session. Unless you save that history, as CoCalc's notebook history does.  
  
I've previously mentioned the _\[now deprecated? —Ed.\]_[nbcomet](https://github.com/activityhistory/nbcomet) ([#TJ16](https://github.com/TrackingJupyter/archive/blob/master/TJ16.md#educationally-relevant); this project itself seemed to build on the earlier [comet](https://github.com/acrule/comet) and [comet\_server](https://github.com/acrule/comet_server) work on tracking changes to notebooks over time) and Microsoft's [nbgather](https://github.com/microsoft/gather) ([#TJ17](https://github.com/TrackingJupyter/archive/blob/master/TJ17.md#news)) but I've recently come across a couple more examples of cell level history capture in the form of _Verdant_ and _ProvBook_.  
  
[Verdant](https://github.com/mkery/Verdant) is _"a JupyterLab extension that automatically records history of all experiments you run in a Jupyter notebook, store them in a tidy .ipyhistory JSON file"_. You can then _"visualize the history of individual cells, code snippets, markdown, and outputs"_. The associated [two minute CHI video](https://www.youtube.com/watch?v=4v_mHIJdZq0&t=4s) _\[that initially reminded me of the [The Machine is Us/ing Us](https://www.youtube.com/watch?v=NLlGopyXT_g) video... —Ed.\]_ provides a good overview. _\[You can also read more via the intriguingly titled [paper](https://marybethkery.com/projects/Verdant/Towards_effective_foraging_by_data_scientists.pdf), "Towards Effective Foraging by Data Scientists to Find Past Analysis Choices"...—Ed.\]_. This extension was originally developed for use "by data scientists", but I think it could also be useful for learners... _\[REDACTED —Ed.\]_  
  
Second up, [ProvBook](https://github.com/Sheeba-Samuel/ProvBook)is a notebook, rather than JupyterLab, extension, that displays the provenance of each notebook code cell through a cell based time slider. Cell history is saved as cell metadata, which can itself be exported to a _.ttl_ RDF datafile. Again there's a [paper](http://ceur-ws.org/Vol-2180/paper-57.pdf) — _ProvBook: Provenance-based Semantic Enrichment of Interactive Notebooks for Reproducibility_ — and again, a [video demo](https://figshare.com/articles/ProvBook_Provenance_of_the_Notebook/6401096), although in this case it comes in at just under 6 minutes, which requires a bit more of a commitment _\[that said, you don't lose much by skipping the first 2 mins...—Ed.\]_.

By the by, it's probably also worth mentioning the [multi-outputs extension](https://blog.ouseful.info/2019/02/11/quick-review-jupyter-multi-outputs-notebook-extension/) and [ordo](https://github.com/nbgallery/ordo) here: both these extensions allow you to save a particular cell output for comparison with the executed output of the same cell at a later point, via a simple diff in the case of the multi-outputs extension, and as part of a simple self-assessment/feedback activity in the case of _ordo_.  

* * *

Disclaimer: this newsletter is produced independently of the official Jupyter project.

_All errors are down to the editor... Oops.. If I make any that I later become aware of, or I'm informed of, I'll announce them in the first possible issue thereafter. If it's really bad, I'll do a Stop Press/emergency issue._

If you have any Jupyter related news items or notebooks you'd like to be considered for inclusion in the newsletter, or experiences of using any of the technologies described in this newsletter that you'd like to share, please email them along to: tony.hirst@open.ac.uk
